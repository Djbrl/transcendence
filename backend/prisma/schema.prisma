// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//Player from 42
model User {
  id             Int           @id @default(autoincrement())
  username       String?       @unique
  email          String        @unique
  password       String
  avatar         String        @default("/avatars/default.jpg") //the path to the avatar image
  isSetup        Boolean       @default(false) //if the user has setup his account
  mfaSecret      String?       // Field to store the 2FA secret
  mfaEnabled       Boolean           @default(false)


  status         String?       @default("OFFLINE")//online, playing, offline
  victories      Int           @default(0) //number of victories for stats
  defeats        Int           @default(0) //number of defeats for stats
  ladderPoint    Int           @default(1000) //level for stats
  // friends        Friend[]      @relation("friends")
  // inverseFriends Friend[]      @relation("inverseFriends") // Only for prisma, not used
  friends Friendship[] @relation("friends")
  friendsOf  Friendship[] @relation("friendsOf")
  blockedUsers   BlockedUser[] @relation("blocked")
  wonGames       Game[]        @relation("winner")
  lostGames      Game[]        @relation("loser")
  channels       ChannelUser[] //channels the user is in
//  history        history[]    //history of DMs, and maybe channels soon
  gameLobby      GameLobby[]   
//  messages       Message[]     @relation("sender")
  socketId       String        @default("") //socket id for the user
  queue          Queue?        // Define the Queue relation here
  twoFa           Int          @default(0) //'on' = 1  or 'off' = 0
  secret         String?       // Field to store the 2FA secret
}

model Friendship {
  friends   User @relation("friends", fields: [friendsId], references: [id])
  friendsId Int
  friendsOf    User @relation("friendsOf", fields: [friendsOfId], references: [id])
  friendsOfId  Int
  accepted  Boolean @default(false)

  @@id([friendsOfId, friendsId])
}


model GameLobby {
  id              Int      @id @default(autoincrement())
  lobbyId         String   @unique
  players         User[]    
  playerOneScore  String
  playerTwoScore  String
}

//Client 1 -> Server (joinLobby : user1, user2) -> user2 hasLobby(user1) -> cancel
//Client 2 -> Server (joinLobby : user1, user2) -> user1 hasLobby(user2) -> cancel

//Timing


//Match
//Define leader
//if not leader wait ping
//if leader create lobby and send socket to follower

//Loop database for match in queues



model Queue {
  id         Int      @id @default(autoincrement())
  confirmed  String   @default("idle")
  username   String   @unique
  profile    User     @relation(fields: [username], references: [username])
}

//Message history (may be used for group chat ?)
//model history {
//  id        Int      @id @default(autoincrement())
//  users     User[]    
//  // channelId Int
//  // channel   Channel? @relation(fields: [channelId], references: [id])
//  content   Message[]
//  date      DateTime @default(now())
//}

//Message content
model Message {
  id          Int       @id @default(autoincrement())
  content     String
  from    Int
//  receiverId  Int?
//  sender      User      @relation("sender", fields: [senderId], references: [id])
//////  receiver    history?   @relation(fields: [receiverId], references: [id])
  channelId   Int
  channel     Channel  @relation(fields: [channelId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  timestamp        DateTime  @default(now())

}

//Friend list
// model Friend {
//   userOneId Int
//   userTwoId Int
//   userOne   User @relation("friends", fields: [userOneId], references: [id])
//   userTwo   User @relation("inverseFriends", fields: [userTwoId], references: [id])

//   @@id([userOneId, userTwoId])
// }

//Blocked list
model BlockedUser {
  userId    Int
  blockedId Int
  user      User @relation("blocked", fields: [userId], references: [id])

  @@id([userId, blockedId])
}

//Game of Pong
model Game {
  id          Int      @id @default(autoincrement())
  winnerId    Int
  loserId     Int
  winner      User     @relation("winner", fields: [winnerId], references: [id])
  loser       User     @relation("loser", fields: [loserId], references: [id])
  winnerScore Int
  loserScore  Int
  date        DateTime @default(now())
}

//Chat channel
model Channel {
  id           Int           @id @default(autoincrement())
  name         String        @unique
  description  String?
  type         ChannelType //public, private, protected or dm
  password     String? //if access is defined as protected
  users        ChannelUser[] //users in the channel
  messages     Message[]//messages in the channel 
  creationDate DateTime      @default(now())
}

model ChannelUser {
  role        Role
  userId      Int
  user        User      @relation(fields: [userId], references: [id])
  channelId   Int
  channel     Channel   @relation(fields: [channelId], references: [id])
  bannedUntil DateTime? //if banned
  mutedUntil  DateTime? //if muted
  readUntil   Int @default(0) // last message read by the user 

  @@id([userId, channelId])
}

//User role in a channel
enum Role {
  USER
  ADMIN
  OWNER
}

//User status
// enum StatusDto {
//   OFFLINE
//   ONLINE
//   PLAYING
// }

//Channel accessibility
enum ChannelType {
  DM
  PUBLIC
  PRIVATE
  PROTECTED
}
